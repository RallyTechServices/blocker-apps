<!DOCTYPE html>
<html>
<head>
    <title>Blocker Percentage of WorkItems</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Fri Jun 03 2016 16:13:34 GMT-0400 (EDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Fri Jun 03 2016 16:13:34 GMT-0400 (EDT)";
        var CHECKSUM = [%= checksum %];
    </script>
    
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0rc3/sdk-debug.js?apiKey=_PUT_APIKEY_HERE_"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.BlockedToolbox',{
    singleton: true,
    /**
     * getBlockedDurations
     *   
     * Returns an array of objects that represent one blocked duration for an artifact and include the following properties:
     *     FormattedID
     *     Name
     *     DateBlocked
     *     DateUnblocked
     *     BlockedReason
     *     
     * Assumes the minimal fetch list:  
     *     Name
     *     FormattedID
     *     _ValidFrom
     *     Blocked
     *     BlockedReason
     *     _PreviousValues.Blocked
     *     _PreviousValues.BlockedReason
     *  
     * Also assumes snapshots are sorted by _ValidFrom in ascending order 
     * 
     */
    getBlockedDurations: function(snaps_by_oid){
        
        var data = [];
        
        Ext.Object.each(snaps_by_oid, function(oid, snaps){
            
            var last_blocked_time = null; 
            var data_record = {FormattedID: null, Name: null, BlockedReason: null, BlockedDate: null, UnblockedDate: null};
            
            Ext.each(snaps, function(snap){
                data_record.FormattedID = snap.FormattedID ;
                data_record.Name = snap.Name ; 
                var is_blocked = snap.Blocked ;
                var was_blocked = is_blocked;  
                if (snap._PreviousValues && (snap._PreviousValues.Blocked != undefined)){
                    was_blocked =  snap._PreviousValues.Blocked;
                } else if (snap["_PreviousValues.Blocked"] != null){
                    was_blocked = snap["_PreviousValues.Blocked"];
                }
                
                var reason = snap.BlockedReason || ''; 
                
                var prev_reason = '';  
                if (snap._PreviousValues && (snap._PreviousValues.BlockedReason != undefined)) {
                    prev_reason = snap._PreviousValues.BlockedReason;
                } else if (snap["_PreviousValues.BlockedReason"]){
                    prev_reason = snap["_PreviousValues.BlockedReason"];
                }
                
                var date = Rally.util.DateTime.fromIsoString(snap._ValidFrom);
                if (was_blocked && prev_reason.length > 0 && (is_blocked == false)){
                    data_record.UnblockedDate = date; 
                    data_record.BlockedReason = prev_reason; 
                    data.push(data_record);  //We push this here so that we can start a new one.  
                    data_record = {FormattedID: snap.FormattedID, Name: snap.Name, BlockedReason: null, BlockedDate: null, UnblockedDate: null};
                    last_blocked_time = null;  
                } 
                
                if (is_blocked && (was_blocked == false)){
                    last_blocked_time = date; 
                }
                if (is_blocked && reason.length > 0 && last_blocked_time){
                    data_record.BlockedReason = reason; 
                    data_record.BlockedDate = last_blocked_time;
//                    last_blocked_time = null;  
                }
            },this);
            
            if (data_record.BlockedDate && data_record.UnblockedDate == null){
                data.push(data_record);
            }
        },this);
        return data;  
    },
    getCountsByReason: function(snaps_by_oid){
        var counts = {};
        var data = [];  
        Ext.Object.each(snaps_by_oid, function(oid, snaps){
            var rec = {FormattedID: null, Name: null, BlockedReason: null};
            Ext.each(snaps, function(snap){
                rec.Name = snap.Name;  
                rec.FormattedID = snap.FormattedID;
                if (snap.BlockedReason){
                    if (counts[snap.BlockedReason] == undefined){
                        counts[snap.BlockedReason] = 0; 
                    } 
                    rec.BlockedReason = snap.BlockedReason;
                    counts[snap.BlockedReason]++; 
                }
            });
            data.push(rec);
        },this);
        return {counts: counts, data: data};  
    },
    bucketDataByDate: function(artifacts, artifactProperty, dateInterval, dateFormat, bucketedDateStrings){
        var buckets = {};

        Ext.each(bucketedDateStrings, function(str){
            buckets[str] = 0;
        });
        
        Ext.Object.each(artifacts, function(key, artifact){
            if (artifact[artifactProperty]){
                var date = Rally.util.DateTime.fromIsoString(artifact[artifactProperty]);
                var bucket = Rally.util.DateTime.format(date,dateFormat);
                if (Ext.Array.contains(bucketedDateStrings,bucket)){
                    buckets[bucket]++;
                }
            }
        });
        
        return buckets;  
    },
    aggregateBlockedTimelines: function(snaps_by_oid){
        var export_data = [];  
        var reason_data = {};  
       
        //Assumption is that these snaps are still sorted by _ValidFrom in ascending order for each oid
        var block_action = {};  
        
        Ext.Object.each(snaps_by_oid, function(oid, snaps){
            var last_blocked_date = null;
            var blocked_actions = [];  
            var formatted_id = snaps[0].get('FormattedID');

            Ext.each(snaps, function(snap){
                var name = snap.get('Name');
                var reason = snap.get('BlockedReason') || null;
                var previous_reason = snap.get('_PreviousValues.BlockedReason') || null;
                var blocked = snap.get('Blocked');
                var was_blocked = snap.get('_PreviousValues.Blocked');
                var date = Rally.util.DateTime.fromIsoString(snap.get('_ValidFrom'));

                var rec = {FormattedID: formatted_id, BlockedDate: null, UnblockedDate: null, BlockedReason: null};
                if (blocked === true && was_blocked === false){
                    //Transition to blocked
                    last_blocked_date = date;
                    rec.BlockedDate = last_blocked_date;
                    rec.BlockedReason = reason;  
                    rec.Name = name; 
                    blocked_actions.push(rec);
                }
                
                if (was_blocked === true && blocked === false){
                    //Transition from blocked 
                    var rec_found = false; 
                    var idx=-1; 
                    for (var i=0; i<blocked_actions.length; i++){
                        if (blocked_actions[i].BlockedDate == last_blocked_date){
                            idx = i;  
                        }
                    }

                    if (idx<0){
                        idx = blocked_actions.length; 
                        blocked_actions.push(rec);  
                    }
                    blocked_actions[idx].Name = name;  
                    blocked_actions[idx].UnblockedDate = date;  
                    blocked_actions[idx].BlockedReason = previous_reason;  
                    last_blocked_date = null; 
                }
            });
            block_action[formatted_id] = blocked_actions;
        });
        return block_action         
    }
});
    Ext.define('Rally.technicalservices.DataExportDialog', {
        extend: 'Rally.ui.dialog.Dialog',
        logger: new Rally.technicalservices.Logger(),
        autoShow: true,
        title: 'Data Dialog',

        constructor: function(config){
            Ext.apply(this,config);
            
            this.title = this.title;
            this.items = this._initializeItems();
            this.logger.log('Data dialog constructor', this.title, this.items);
            
            this.callParent(arguments);
       },
       _initializeItems: function(){
           var items = [];
           this.logger.log('_initializeItems', this.data);
           items.push(this._buildGrid());
           items.push({xtype:'container',itemId: 'button-container', layout: {type: 'hbox'}, items: [{
                    xtype     : 'rallybutton',
                    text      : 'Export',
                    scope: this,
                    handler      : this._export
                },{
                    xtype     : 'rallybutton',
                    text      : 'Close',
                    scope: this,
                    handler      : this._close
                }]});
           return items;
      },
      _buildGrid: function(){
          this.logger.log('_buildGrid');
          
          var store = Ext.create('Rally.data.custom.Store', {
              data: this.data,
              pageSize: 10
          });
          
          return {
              xtype:'rallygrid',
              store: store,
              columnCfgs: this._getColumnCfgs(this.data),
              height: this.height - 100,
              pagingToolbarCfg: {
                  pageSizes: [5, 10, 25]
               }
          };
      },
      _getColumnCfgs: function(data){
          var headers = Ext.Object.getKeys(data[0]);
          var column_cfgs = [];
          Ext.each(headers, function(header){
              column_cfgs.push({flex: 1, text: header, dataIndex: header});
          });
          return column_cfgs;  
      },
      _export: function(){
          var file_name = "export.csv";
          var data_hash = {};
          Ext.each(Ext.Object.getKeys(this.data[0]), function(key){
              data_hash[key] = key;
          });
          this.logger.log('_export',data_hash, this.data);
          
          var export_text = Rally.technicalservices.FileUtilities.convertDataArrayToCSVText(this.data, data_hash);
          Rally.technicalservices.FileUtilities.saveTextAsFile(export_text,file_name);
      },
      _close: function(){
          this.destroy();
      }
    });
Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),
    
    saveTextAsFile: function(textToWrite, fileName)
    {
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = this.destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash){
       
        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key){
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/,'\n');
        
        Ext.each(data_array, function(d){
            Ext.each(Object.keys(requestedFieldHash), function(key){
                if (d[key]){
                    if (typeof d[key] === 'object'){
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",",d[key].FormattedID ); 
                        } else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",",d[key].Name );                    
                        } else if (!isNaN(Date.parse(d[key]))){
                            text += Ext.String.format("\"{0}\",",Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        }else {
                            text += Ext.String.format("\"{0}\",",d[key].toString());
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",",d[key] );                    
                    }
                } else {
                    text += ',';
                }
            },this);
            text = text.replace(/,$/,'\n');
        },this);
        return text;
    }
});
Ext.override(Rally.ui.chart.Chart,{
    _loadStore: function (storeConfig, storeRank) {

        var self = this;

        Ext.merge(storeConfig, {
            exceptionHandler: function (proxy, response, operation) {
                console.log(proxy,response,operation);
                if (response.status !== 200) {
                    self.queryValid = false;
                }
                if (response.status === 409) {
                    self.workspaceHalted = true;
                } else if (response.status === 503) {
                    self.serviceUnavailable = true;
                }
            }
        });

        storeConfig.limit = storeConfig.limit || Infinity;

        var store = Ext.create(this.storeType, storeConfig);
        store.rank = storeRank;

        store.on('load', this._storeLoadHandler, this);
        store.load({params: { removeUnauthorizedSnapshots: true } });
    }
});

    Ext.define('Rally.technicalservices.calculator.StateTouchCalculator', {
        extend: 'Rally.data.lookback.calculator.BaseCalculator',

        config: {
            startDate: null,
            endDate: null,
            dateFormat: "F",
            granularity: "month"
        },

        /**
         * Calculate extra chart fields that are derived based on the data retrieved by the store. This is passed
         * to the Lumenize {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the
         * configuration. For example, if you want to calculate the number of completed stories, you would simply return
         * if the story is in a completed schedule state or not:
         *   return [{
         *       "as": "CompletedStoryCount",
         *       "f": function(snapshot) {
         *           var ss = snapshot.ScheduleState;
         *           if (ss === "Accepted" || ss === "Released") {
         *               return 1;
         *           }
         *           else {
         *               return 0;
         *           }
         *       }
         *   }];
         *
         * You can use these derived fields as part of the calculator metrics calculation.
         *
         * Object properties:
         *
         *   - The `as` property is the name the field is saved as for future reference
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `snapshot` as
         *   an argument
         *
         * @return {Array} a list of derived fields objects
         */
        getDerivedFieldsOnInput: function () {
            return [];
        },

        /**
         * Calculate the metrics that are displayed on the chart from the data retrieved by the store. This is passed
         * to the Lumenize {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the
         * configuration. Metrics calculations can use fields that are derived using the #getDerivedFieldsOnInput
         * function. For example, if I derived a CompletedStoryCount field, I can display that field as a bar chart by
         * specifying:
         *   return [{
         *      "field": "CompletedStoryCount",





         *      "as": "Completed Stories",
         *      "f": "sum",
         *      "display": "column"
         *   }];
         *
         * The field is displayed in the chart as "Completed Stories" with each bar being a sum of that days completed
         * stories.
         *
         * Object properties:
         *
         *   - The `field` property is the field name to use to calculate the metric. This can be a field from the data
         *   or a derived field.
         *   - The `as` property is the name displayed to the user in the chart
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `snapshot` as
         *   an argument
         *   - The `display` property is used by the chart to determine how to display the data on a chart. Can be any
         *   Highcharts specific type, e.g., "line" or "column"
         *
         * @return {Array} a list of metric objects
         */
        getMetrics: function () {
            return [];
        },

        /**
         * Calculate summary metrics based on the data retrieved from the store. This is passed to the Lumenize
         * {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the configuration.
         * Each summary metric also has access to any previously defined metrics or derived fields. This function is
         * useful to generate data that you do not necessarily want to render on the chart, but would like to use to get
         * more derived fields after the main chart metrics are defined. For example, if you wanted the max numbers for
         * different fields, you would specify:
         *      return [
         *          { "field": "TaskUnitScope", "f": "max" },
         *          { "field": "TaskUnitBurnDown", "f": "max" },
         *      ];
         *
         * The fields would then be available to the objects in #getDerivedFieldsAfterSummary. Note that the fields in
         * this case will need to be referenced by `TaskUnitScope_max` due to the use of the built-in `max` function. If
         * you wish to specify your own function, you must use the `as` property in order to reference the field in the
         * future. For example,
         *      return [{
         *          "as": "TaskUnitBurnDown_max_index",
         *          "f": function(seriesData, metrics) {
         *              var i, length = seriesData.length;
         *              for(i = 0; i < length; i++) {
         *                  var data = seriesData[i];
         *                  if(data.TaskUnitBurnDown == metrics.TaskUnitBurnDown_max) {
         *                      return i;
         *                  }
         *              }
         *          }
         *      }];
         *
         * Object properties:
         *
         *   - The `field` property is the name of the field to use to calculate the new summary metric. This field
         *   can be from the data or from a previously derived field.
         *   - The `as` property is only used when you supply a custom function to calculate the summary metric. It is
         *   the name for future reference of the field.
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `seriesData`
         *   and `metrics` as arguments. This is used in conjunction with the `as` property.
         *
         * @return {Array}
         */
        getSummaryMetricsConfig: function () {
            return [];
        },

        /**
         * Calculate extra chart fields to display on the chart using the fields defined in by the summary metrics
         * configuration. This is passed to the {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator} as
         * part of the configuration. This function is useful when you want to derive more fields to display on your
         * chart. For example, if you wanted to calculate an ideal line for a burn chart using the `TaskUnitScope_max`
         * field, you would specify:
         *      return [{
         *          "as": "Ideal",
         *          "f": function(snapshot, index, metrics, seriesData) {
         *              var max = metrics.TaskUnitScope_max,
         *                  increments = seriesData.length - 1,
         *                  incrementAmount = max / increments;
         *
         *              return Math.floor(100 * (max - index * incrementAmount)) / 100;
         *          },
         *          "display": "line"
         *      }];
         *
         * This field would be displayed in the chart as an ideal line for the given data.
         *
         * Object properties:
         *
         *   - The `as` property is the name displayed to the user in the chart
         *   - The `f` property is a custom function that takes a snapshot, index, chart metrics, and the series data as
         *   arguments
         *   - The `display` property is used by the chart to determine how to display the data on a chart. Can be any
         *   Highcharts specific type, e.g., "line" or "column"
         *
         * @return {Array}
         */
        getDerivedFieldsAfterSummary: function () {
            return [];
        },

        /**
         * @inheritdoc
         */
        runCalculation: function (snapshots) {
            
            var snaps_by_oid = Rally.technicalservices.Toolbox.aggregateSnapsByOid(snapshots);
            

            var date_buckets = Rally.technicalservices.Toolbox.getDateBuckets(this.startDate, this.endDate, this.granularity);
            var series = this._getSeries(snaps_by_oid,date_buckets,this.granularity);
            var categories = Rally.technicalservices.Toolbox.formatDateBuckets(date_buckets, this.dateFormat);  
            return {categories: categories, series: series};
        },
        _getSeries: function(snaps_by_oid, buckets, granularity){
            
            var total_counter = _.range(buckets.length).map(function () { return 0 }),
                blocked_counter =_.range(buckets.length).map(function () { return 0 });
            var export_data = []; 
            
            Ext.Object.each(snaps_by_oid, function(oid, snaps){
                var oid_end_date = null, oid_start_date = null,
                    oid_blocked_end_date = null, oid_blocked_start_date = null,
                    oid_blocked = false, reason = null, fid = null, name = null; 
                
                Ext.each(snaps, function(snap){
                    reason = snap.BlockedReason;  
                    name = snap.Name;
                    fid = snap.FormattedID;  
                    
                    var snap_from_date = Rally.util.DateTime.fromIsoString(snap._ValidFrom);
                    if (oid_start_date == null ||  snap_from_date < oid_start_date){
                        oid_start_date = snap_from_date;
                    }
                    var snap_to_date = Rally.util.DateTime.fromIsoString(snap._ValidTo);
                    if (oid_end_date == null || oid_end_date < snap_to_date){
                        oid_end_date = snap_to_date;
                    }
                    
                    if (snap.Blocked){
                        oid_blocked = true; 
                        if (oid_blocked_start_date == null || oid_blocked_start_date > snap_from_date){
                            oid_blocked_start_date = snap_from_date;
                        }
                        if (oid_blocked_end_date == null || oid_blocked_end_date < snap_to_date){
                            oid_blocked_end_date = snap_to_date;  
                        }
                    }
                });
                var data = {FormattedID: fid, Name: name, Blocked: oid_blocked, BlockedDate: oid_blocked_start_date, UnblockedDate: oid_blocked_end_date};
                for (var i=0; i<buckets.length; i++){
                    data[Rally.util.DateTime.format(buckets[i],this.dateFormat)] = 0;
                    if (oid_end_date >= buckets[i] && oid_start_date < Rally.util.DateTime.add(buckets[i],granularity,1)){
                        total_counter[i]++;
                    }
                    if (oid_blocked){
                      if (oid_blocked_start_date < Rally.util.DateTime.add(buckets[i],granularity,1) && oid_blocked_end_date >= buckets[i]){
                            data[Rally.util.DateTime.format(buckets[i],this.dateFormat)] = 1;  
                            blocked_counter[i]++;
                        }
                    }
                }
                export_data.push(data);
            },this);
            
            var blocked_pct = _.range(buckets.length).map(function () { return 0 }),
            not_blocked_pct = _.range(buckets.length).map(function () { return 0 });  
            
            for(var i=0; i< buckets.length; i++){
                blocked_pct[i] = Math.round(blocked_counter[i]/total_counter[i] * 100);
                not_blocked_pct[i] = Math.round((total_counter[i] - blocked_counter[i])/total_counter[i] *100);  
            }
            this.data = export_data; 
            return [{name: '% Not Blocked', data: not_blocked_pct, stack: 1},
                    {name: '% Blocked', data: blocked_pct, stack: 1}];
        },
        getData: function(){
            return this.data; 
        }

    });
Ext.define('Rally.technicalservices.Toolbox',{
    singleton: true,
    /**
     * Returns beginnig of month as date for the current time zone
     * 
     */
    getBeginningOfMonthAsDate: function(dateInMonth){
        var year = dateInMonth.getFullYear();
        var month = dateInMonth.getMonth();
        return new Date(year,month,1,0,0,0,0);
    },
    getEndOfMonthAsDate: function(dateInMonth){
        var year = dateInMonth.getFullYear();
        var month = dateInMonth.getMonth();
        var day = new Date(year, month+1,0).getDate();
        return new Date(year,month,day,0,0,0,0);
    },
    aggregateSnapsByOid: function(snaps){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object
        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){
            var oid = snap.ObjectID || snap.get('ObjectID');
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(snap);
            
        });
        return snaps_by_oid;
    },
    getCaseInsensitiveKey: function(obj, inputStr){
        var new_key = inputStr;
        Ext.Object.each(obj, function(key, val){
            if (new_key.toLowerCase() == key.toLowerCase()){
                new_key = key;  
            }
         });
        return new_key;

    },
    aggregateSnapsByOidForModel: function(snaps){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object
        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){
            var oid = snap.ObjectID || snap.get('ObjectID');
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(snap.getData());
            
        });
        return snaps_by_oid;
    },
    getDateBuckets: function(startDate, endDate, granularity){

        var bucketStartDate = Rally.technicalservices.Toolbox.getBeginningOfMonthAsDate(startDate);
        var bucketEndDate = Rally.technicalservices.Toolbox.getEndOfMonthAsDate(endDate);
       
        var date = bucketStartDate;
        
        var buckets = []; 
        while (date<bucketEndDate && bucketStartDate < bucketEndDate){
            buckets.push(date);
            date = Rally.util.DateTime.add(date,granularity,1);
        }
        return buckets;  
    },
    formatDateBuckets: function(buckets, dateFormat){
            var categories = [];
            Ext.each(buckets, function(bucket){
                categories.push(Rally.util.DateTime.format(bucket,dateFormat));
            });
            categories[categories.length-1] += "*"; 
            return categories; 
    },


});
Ext.override(Ext.data.proxy.Server, {
    timeout : 180000,
    processResponse: function(success, operation, request, response, callback, scope) {
        var me = this,
            reader,
            result;

        if (success === true) {
            reader = me.getReader();
            reader.applyDefaults = operation.action === 'read';
            result = reader.read(me.extractResponseData(response));

            if (result.success !== false) {

                Ext.apply(operation, {
                    response: response,
                    resultSet: result
                });

                operation.commitRecords(result.records);
                operation.setCompleted();
                operation.setSuccessful();
            } else {
                operation.setException(result.message);
                me.fireEvent('exception', this, response, operation);
            }
        } else {
            if (response) {
                me.setException(operation, response);
            }
            me.fireEvent('exception', this, response, operation);
        }


        if (typeof callback == 'function') {
            callback.call(scope || me, operation);
        }

        me.afterRequest(request, success);
    },


    setException: function(operation, response) {
        operation.setException({
            status: response.status ,
            statusText: response.statusText
        });
    },


    extractResponseData: Ext.identityFn,


    applyEncoding: function(value) {
        return Ext.encode(value);
    },
});

Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [
        {xtype:'container',itemId:'selection_box',layout: {type: 'hbox'}, padding: 10},
        {xtype:'container',itemId:'time_box', layout: {type: 'hbox'}, padding: 10},
        {xtype:'container',itemId:'display_box'},
        {xtype:'tsinfolink'}
    ],
    
    chartTitle: 'Blockers as a percentage of Work Items',
    pickerOptions: [
        {name: 'Last Complete Month', value: -1},
        {name: 'Last 2 Complete Months', value: -2},
        {name: 'Last 3 Complete Months', value: -3},
        {name: 'Last 6 Complete Months', value: -6},
        {name: 'Last 12 Complete Months', value: -12}
    ],
    types: ['HierarchicalRequirement','Defect'],
    defaultPickerOption: 'Last 3 Complete Months',
    launch: function() {
        this._initialize();
    },
    _initialize: function(){
        var store = Ext.create('Ext.data.Store',{
            fields: ['name','value'],
            data: this.pickerOptions
        });

        var me = this;

        var store = Ext.create('Ext.data.Store',{
            fields: ['name','value'],
            data: this.pickerOptions
        });

        this.down('#selection_box').add(
        {
            xtype      : 'radiogroup',
            fieldLabel : 'Select data for ',
            defaults: {
                flex: 1
            },
            layout: 'hbox',
            items: [
                {
                    boxLabel  : 'Time Period',
                    name      : 'timebox',
                    inputValue: 'T',
                    id        : 'radio1',
                    checked   : true,
                    margin: '0 0 0 10'   
                }, {
                    boxLabel  : 'Iteration',
                    name      : 'timebox',
                    inputValue: 'I',
                    id        : 'radio2',
                    margin: '0 0 0 10'
                }, {
                    boxLabel  : 'Release',
                    name      : 'timebox',
                    inputValue: 'R',
                    id        : 'radio3',
                    margin: '0 0 0 10'
                }
            ],
            listeners:{
                change: function(rb){
                    if(rb.lastValue.timebox == 'T'){
                        me.down('#time_box').removeAll();
                            me.down('#time_box').add({
                                xtype: 'combobox',
                                store: store,
                                queryMode: 'local',
                                fieldLabel: 'Show data from',
                                displayField: 'name',
                                valueField: 'value',
                                minWidth: 300,
                                value: -3,
                                name:'TimePeriod',
                                listeners: {
                                    scope: me,
                                    select: me._buildChart,
                                    ready:me._buildChart
                                }
                            });
                            
                    }else if(rb.lastValue.timebox == 'I'){
                            //console.log('me>>',me);
                            me.down('#time_box').removeAll();
                            me.down('#time_box').add({
                                xtype: 'rallyiterationcombobox',
                                fieldLabel: 'Iteration: ',
                                minWidth: 300,
                                listeners: {
                                    scope: me,
                                    select: function(icb){
                                        me._getReleaseOrIterationOids(icb);
                                    },
                                    ready: function(icb){
                                        me._getReleaseOrIterationOids(icb);
                                    }
                                }
                            });

                    }else if(rb.lastValue.timebox == 'R'){
                            me.down('#time_box').removeAll();
                            me.down('#time_box').add({
                                xtype: 'rallyreleasecombobox',
                                fieldLabel: 'Release: ',
                                minWidth: 300,
                                value: -3,
                                listeners: {
                                    scope: me,
                                    select: function(icb){
                                        me._getReleaseOrIterationOids(icb);
                                    },
                                    ready: function(icb){
                                        me._getReleaseOrIterationOids(icb);
                                    }                                 }
                            });
                    }
                }
            }
        }
        );
        
        var cb = this.down('#time_box').add({
            xtype: 'combobox',
            store: store,
            queryMode: 'local',
            fieldLabel: 'Show data from',
            displayField: 'name',
            valueField: 'value',
            minWidth: 300,
            value: -3,
            listeners: {
                scope: this,
                select: this._buildChart  
            }
        });
        this.down('#selection_box').add({
            xtype: 'rallybutton',
            itemId: 'btn-data',
            text: 'Data...',
            scope: this, 
            margin: '0 0 0 10',
            handler: this._viewData
        });
        this._buildChart(cb);
    }, 

    _getReleaseOrIterationOids: function(cb) {
        var me = this;
        me.logger.log('_getReleaseOrIterationOids',cb);
        me.timeboxValue = cb;
        Deft.Chain.parallel([
                me._getReleasesOrIterations
        ],me).then({
            scope: me,
            success: function(results) {
                me.logger.log('Results:',results);
                
                me.timebox_oids = Ext.Array.map(results[0], function(timebox) {
                    return timebox.get('ObjectID');
                });
                me._buildChart(cb);
            },
            failure: function(msg) {
                Ext.Msg.alert('Problem Loading Timebox data', msg);
            }
        });
    },


    _getReleasesOrIterations:function(){
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        this.logger.log('_getReleasesOrIterations>>',me.timeboxValue);

        var timeboxModel = '';
        var filters = [];

        if(me.timeboxValue.name == 'Iteration'){
            timeboxModel = 'Iteration';
            filters =         [        {
                    property: 'Name',
                    operator: '=',
                    value: me.timeboxValue.getRecord().get('Name')
                }
                ,
                {
                    property: 'StartDate',
                    operator: '=',
                    value: me.timeboxValue.getRecord().get('StartDate').toISOString()
                },
                {
                    property: 'EndDate',
                    operator: '=',
                    value: me.timeboxValue.getRecord().get('EndDate').toISOString()
                }
            ];
        }else if(me.timeboxValue.name == 'Release'){
            timeboxModel = 'Release';  
            filters =         [        {
                    property: 'Name',
                    operator: '=',
                    value: me.timeboxValue.getRecord().get('Name')
                }
                ,
                {
                    property: 'ReleaseStartDate',
                    operator: '=',
                    value: me.timeboxValue.getRecord().get('ReleaseStartDate').toISOString()
                },
                {
                    property: 'ReleaseDate',
                    operator: '=',
                    value: me.timeboxValue.getRecord().get('ReleaseDate').toISOString()
                }
            ];
        }

        Ext.create('Rally.data.wsapi.Store', {
            model: timeboxModel,
            fetch: ['ObjectID'],
            filters: Rally.data.wsapi.Filter.and(filters)
        }).load({
            callback : function(records, operation, successful) {
                if (successful){
                    //console.log('records',records,'operation',operation,'successful',successful);
                    deferred.resolve(records);
                } else {
                    me.logger.log("Failed: ", operation);
                    deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
                }
            }
        });
        return deferred.promise;
    },

    _viewData: function(){
        this.logger.log('_viewData');
        
        var data = this.down('#crt').calculator.getData();  
        var height = this.getHeight() || 500;
        var width = this.getWidth() || 800;
        
        if ( width > 800 ) {
            width = 800;
        }
        if ( height > 550 ) {
            height = 550;
        }
        if ( height < 200 ) {
            alert("The app panel is not tall enough to allow for displaying data.");
        } else {        
            Ext.create('Rally.technicalservices.DataExportDialog', {
                draggable: true,
                modal: true,
                width: width,
                height: height,
                autoShow: true,
                title: 'Data for ' + this.chartTitle,
                data: data
            });
        }
     },    

    _buildChart: function(cb){
        var me = this;

        var project = this.getContext().getProject().ObjectID;  
        //var start_date = Rally.util.DateTime.add(new Date(),"month",cb.getValue());

        var start_date , end_date = new Date();
        if(cb.name == 'Iteration'){
            if(me.timeboxValue){
                start_date = new Date(me.timeboxValue.getRecord().get('StartDate'));
                end_date = new Date(me.timeboxValue.getRecord().get('EndDate'));
            }
        }else if(cb.name == 'Release'){
            if(me.timeboxValue){
                start_date = new Date(me.timeboxValue.getRecord().get('ReleaseStartDate'));
                end_date = new Date(me.timeboxValue.getRecord().get('ReleaseDate'));
            }
        }else{
            start_date = Rally.technicalservices.Toolbox.getBeginningOfMonthAsDate(Rally.util.DateTime.add(new Date(), "month",cb.getValue()));
        }

        var find = {$and: [{"ScheduleState":"In-Progress"}, {'_ProjectHierarchy': project},{'_TypeHierarchy': {$in: this.types}},
                      {$or: [{
                          "_ValidFrom": {$gt: Rally.util.DateTime.toIsoString(start_date)}
                      },{
                          "__At": Rally.util.DateTime.toIsoString(start_date)
                      }]
                      }]
                };

        if(cb.name == 'Iteration'){
            find["Iteration"] = { '$in': this.timebox_oids };
        }else if(cb.name == 'Release'){
            find["Release"] = { '$in': this.timebox_oids };
        }

        this.logger.log('_buildChart', project, start_date);
        
        this.down('#display_box').removeAll();
        
        var chart = this.down('#display_box').add({
            xtype: 'rallychart',
            itemId: 'crt',
            chartColors:['#8bbc21','#c42525'],
            calculatorType:  'Rally.technicalservices.calculator.StateTouchCalculator',
            calculatorConfig: {
                startDate: start_date,
                endDate: new Date()
            },
            storeConfig: {
                fetch: ['Blocked','BlockedReason','Name','FormattedID'],
                limit: 'Infinity',
                find: find,
                removeUnauthorizedSnapshots: true
            },
            chartConfig: {
                    chart: {
                        type: 'column'
                    },
                    title: {
                        text: this.chartTitle
                    },
                    yAxis: {
                        min: 0,
                        title: {text: ''},
                        max: 100,
                        labels: {
                            format: '{value}%'
                        }
                    },
                    plotOptions: {
                        column: {
                            stacking: "normal"
                        }
                    }
            }
        });
        
    },
});
            
               Rally.launchApp('CustomApp', {
                   name: 'Blocker Percentage of WorkItems'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>